// DataHaven Storage Operations - Bucket & File Management for Audit Proofs
import '@storagehub/api-augment';
import { FileManager, ReplicationLevel } from '@storagehub-sdk/core';
import { TypeRegistry } from '@polkadot/types';
import {
  getStorageHubClient,
  getConnectedAddress,
  getPublicClient,
  getPolkadotApi,
  buildGasTxOpts,
  initPolkadotApi,
} from './clientService';
import { getMspClient, getMspInfo, getValueProps, authenticateUser, isAuthenticated } from './mspService';
import { NETWORKS } from '../config/networks';

// Create a new bucket for audit proofs
export async function createBucket(bucketName, isPrivate = false) {
  const storageHubClient = getStorageHubClient();
  const address = getConnectedAddress();
  const publicClient = getPublicClient();
  const polkadotApi = await initPolkadotApi();

  if (!address) {
    throw new Error('Wallet not connected');
  }

  // Get MSP info and value prop
  const { mspId } = await getMspInfo();
  const valuePropId = await getValueProps();

  // Derive bucket ID
  const bucketId = await storageHubClient.deriveBucketId(address, bucketName);

  // Check that bucket doesn't already exist
  const bucketBeforeCreation = await polkadotApi.query.providers.buckets(bucketId);
  if (!bucketBeforeCreation.isEmpty) {
    // Bucket already exists, return it
    return { bucketId, txHash: null, alreadyExists: true };
  }

  // Build gas options
  const gasTxOpts = await buildGasTxOpts();

  // Create bucket on chain
  const txHash = await storageHubClient.createBucket(
    mspId,
    bucketName,
    isPrivate,
    valuePropId,
    gasTxOpts
  );

  if (!txHash) {
    throw new Error('createBucket() did not return a transaction hash');
  }

  // Wait for transaction receipt
  const txReceipt = await publicClient.waitForTransactionReceipt({
    hash: txHash,
  });

  if (txReceipt.status !== 'success') {
    throw new Error(`Bucket creation failed: ${txHash}`);
  }

  return { 
    bucketId, 
    txHash, 
    txReceipt,
    explorerUrl: `${NETWORKS.testnet.explorerUrl}/tx/${txHash}`,
    alreadyExists: false 
  };
}

// Wait for backend to index the bucket
export async function waitForBackendBucketReady(bucketId) {
  const mspClient = getMspClient();
  const maxAttempts = 10;
  const delayMs = 2000;

  for (let i = 0; i < maxAttempts; i++) {
    try {
      const bucket = await mspClient.buckets.getBucket(bucketId);
      if (bucket) {
        return bucket;
      }
    } catch (error) {
      if (error.status === 404 || error.body?.error === 'Not found: Record') {
        // Bucket not yet indexed, continue polling
      } else {
        throw error;
      }
    }
    await new Promise((r) => setTimeout(r, delayMs));
  }
  throw new Error(`Bucket ${bucketId} not found in MSP backend after waiting`);
}

// Upload an audit proof as a JSON file
export async function uploadAuditProof(bucketId, proofData) {
  const storageHubClient = getStorageHubClient();
  const publicClient = getPublicClient();
  const polkadotApi = await initPolkadotApi();
  const mspClient = getMspClient();
  const address = getConnectedAddress();

  if (!address) {
    throw new Error('Wallet not connected');
  }

  // Create proof JSON with timestamp
  const proofPayload = {
    ...proofData,
    timestamp: new Date().toISOString(),
    version: '1.0',
    type: 'metamorphosis_audit_proof',
  };

  const fileName = `audit_proof_${Date.now()}.json`;
  const fileContent = JSON.stringify(proofPayload, null, 2);
  const fileBytes = new TextEncoder().encode(fileContent);

  // Create FileManager from bytes
  const fileManager = new FileManager({
    size: fileBytes.length,
    stream: () =>
      new ReadableStream({
        start(controller) {
          controller.enqueue(fileBytes);
          controller.close();
        },
      }),
  });

  // Get file details
  const fingerprint = await fileManager.getFingerprint();
  const fileSizeBigInt = BigInt(fileManager.getFileSize());

  // Get MSP details
  console.log('Getting MSP info for file upload...');
  const mspInfo = await getMspInfo();
  console.log('MSP info retrieved:', mspInfo);
  
  const mspId = mspInfo?.mspId || mspInfo?.id;
  const multiaddresses = mspInfo?.multiaddresses;

  if (!mspId) {
    throw new Error('MSP ID not found in MSP info');
  }

  if (!multiaddresses || !Array.isArray(multiaddresses) || multiaddresses.length === 0) {
    throw new Error('MSP multiaddresses are missing or empty. Please ensure MSP is properly connected and authenticated.');
  }

  // Extract peer IDs from multiaddresses
  const peerIds = (multiaddresses ?? [])
    .map((addr) => addr.split('/p2p/').pop())
    .filter((id) => !!id);

  if (peerIds.length === 0) {
    throw new Error('MSP multiaddresses had no /p2p/<peerId> segment');
  }

  // Build gas options
  const gasTxOpts = await buildGasTxOpts();

  // Issue storage request (on-chain)
  const txHash = await storageHubClient.issueStorageRequest(
    bucketId,
    fileName,
    fingerprint.toHex(),
    fileSizeBigInt,
    mspId,
    peerIds,
    ReplicationLevel.Custom,
    1, // replicas
    gasTxOpts
  );

  if (!txHash) {
    throw new Error('issueStorageRequest() did not return a transaction hash');
  }

  // Wait for transaction
  const receipt = await publicClient.waitForTransactionReceipt({
    hash: txHash,
  });

  if (receipt.status !== 'success') {
    throw new Error(`Storage request failed: ${txHash}`);
  }

  // Compute file key (this is the CID equivalent)
  const registry = new TypeRegistry();
  const owner = registry.createType('AccountId20', address);
  const bucketIdH256 = registry.createType('H256', bucketId);
  const fileKey = await fileManager.computeFileKey(owner, bucketIdH256, fileName);

  // Verify storage request on chain
  const storageRequest = await polkadotApi.query.fileSystem.storageRequests(fileKey);
  if (!storageRequest.isSome) {
    throw new Error('Storage request not found on chain');
  }

  // Authenticate if not already
  if (!isAuthenticated()) {
    await authenticateUser();
  }

  // Upload file to MSP (off-chain)
  const fileBlob = await fileManager.getFileBlob();
  const uploadReceipt = await mspClient.files.uploadFile(
    bucketId,
    fileKey.toHex(),
    fileBlob,
    address,
    fileName
  );

  if (uploadReceipt.status !== 'upload_successful') {
    throw new Error('File upload to MSP failed');
  }

  return {
    fileKey: fileKey.toHex(),
    fileName,
    txHash,
    bucketId,
    fingerprint: fingerprint.toHex(),
    explorerUrl: `${NETWORKS.testnet.explorerUrl}/tx/${txHash}`,
    proofPayload,
  };
}

// Wait for MSP to confirm on chain
export async function waitForMSPConfirmOnChain(fileKey) {
  const polkadotApi = await initPolkadotApi();
  const maxAttempts = 20;
  const delayMs = 2000;

  for (let i = 0; i < maxAttempts; i++) {
    const req = await polkadotApi.query.fileSystem.storageRequests(fileKey);
    if (req.isNone) {
      throw new Error(`StorageRequest for ${fileKey} no longer exists on-chain.`);
    }
    const data = req.unwrap();
    const mspStatus = data.mspStatus;

    const mspConfirmed = mspStatus.isAcceptedNewFile || mspStatus.isAcceptedExistingFile;

    if (mspConfirmed) {
      return true;
    }

    await new Promise((r) => setTimeout(r, delayMs));
  }
  throw new Error(`FileKey ${fileKey} not confirmed by MSP after waiting`);
}

// Get buckets from MSP
export async function getBucketsFromMSP() {
  try {
    const mspClient = getMspClient();
    const buckets = await mspClient.buckets.listBuckets();
    return Array.isArray(buckets) ? buckets : [];
  } catch (err) {
    console.warn('Failed to get buckets from MSP:', err);
    return [];
  }
}

// Get a single bucket info
export async function getBucket(bucketId) {
  const mspClient = getMspClient();
  const bucket = await mspClient.buckets.getBucket(bucketId);
  return bucket;
}

// Get files in a bucket
export async function getBucketFilesFromMSP(bucketId) {
  const mspClient = getMspClient();
  const files = await mspClient.buckets.getFiles(bucketId);
  return files;
}

// Delete a bucket
export async function deleteBucket(bucketId) {
  const storageHubClient = getStorageHubClient();
  const publicClient = getPublicClient();

  const gasTxOpts = await buildGasTxOpts();

  const txHash = await storageHubClient.deleteBucket(bucketId, gasTxOpts);

  if (!txHash) {
    throw new Error('deleteBucket() did not return a transaction hash');
  }

  const receipt = await publicClient.waitForTransactionReceipt({
    hash: txHash,
  });

  if (receipt.status !== 'success') {
    throw new Error(`Bucket deletion failed: ${txHash}`);
  }

  return { txHash, explorerUrl: `${NETWORKS.testnet.explorerUrl}/tx/${txHash}` };
}
